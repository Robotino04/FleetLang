use crate::{
    ast::{
        ArrayExpression, ArrayIndexExpression, ArrayIndexLValue, ArrayType, AstNode,
        BinaryExpression, BlockStatement, BreakStatement, CastExpression, CompilerExpression,
        ExpressionStatement, ExternFunctionBody, ForLoopStatement, FunctionCallExpression,
        FunctionDefinition, GPUExecutor, GroupingExpression, GroupingLValue, IdkType, IfStatement,
        LiteralExpression, OnStatement, Program, ReturnStatement, SelfExecutorHost, SimpleBinding,
        SimpleType, SkipStatement, StatementFunctionBody, ThreadExecutor, UnaryExpression,
        UnitType, VariableAccessExpression, VariableAssignmentExpression,
        VariableDefinitionStatement, VariableLValue, WhileLoopStatement,
    },
    tokenizer::Token,
};

pub fn first_token_of_node<I>(node: &I) -> Option<Token>
where
    I: Into<AstNode> + Clone,
{
    match node.clone().into() {
        AstNode::Program(Program {
            top_level_statements: functions,
            id: _,
            file_name: _,
        }) => functions.iter().flat_map(first_token_of_node).next(),
        AstNode::FunctionDefinition(FunctionDefinition {
            let_token,
            name: _,
            name_token: _,
            equal_token: _,
            open_paren_token: _,
            parameters: _,
            close_paren_token: _,
            right_arrow_token: _,
            return_type: _,
            body: _,
            id: _,
        }) => Some(let_token),
        AstNode::ExternFunctionBody(ExternFunctionBody {
            at_token,
            extern_token: _,
            symbol: _,
            symbol_token: _,
            semicolon_token: _,
            id: _,
        }) => Some(at_token),
        AstNode::StatementFunctionBody(StatementFunctionBody { statement, id: _ }) => {
            first_token_of_node(&statement)
        }
        AstNode::SimpleBinding(SimpleBinding {
            name_token,
            name: _,
            type_: _,
            id: _,
        }) => Some(name_token),
        AstNode::ExpressionStatement(ExpressionStatement {
            expression,
            semicolon_token: _,
            id: _,
        }) => first_token_of_node(&expression),
        AstNode::OnStatement(OnStatement {
            on_token,
            executor: _,
            iterators: _,
            open_paren_token: _,
            bindings: _,
            close_paren_token: _,
            body: _,
            id: _,
        }) => Some(on_token),
        AstNode::BlockStatement(BlockStatement {
            open_brace_token,
            body: _,
            close_brace_token: _,
            id: _,
        }) => Some(open_brace_token),
        AstNode::ReturnStatement(ReturnStatement {
            return_token,
            value: _,
            semicolon_token: _,
            id: _,
        }) => Some(return_token),

        AstNode::VariableDefinitionStatement(VariableDefinitionStatement {
            let_token,
            binding: _,
            equals_token: _,
            value: _,
            semicolon_token: _,
            id: _,
        }) => Some(let_token),
        AstNode::IfStatement(IfStatement {
            if_token,
            condition: _,
            if_body: _,
            elifs: _,
            else_: _,
            id: _,
        }) => Some(if_token),
        AstNode::WhileLoopStatement(WhileLoopStatement {
            while_token,
            condition: _,
            body: _,
            id: _,
        }) => Some(while_token),
        AstNode::ForLoopStatement(ForLoopStatement {
            for_token,
            open_paren_token: _,
            initializer: _,
            condition: _,
            second_semicolon_token: _,
            incrementer: _,
            close_paren_token: _,
            body: _,
            id: _,
        }) => Some(for_token),
        AstNode::BreakStatement(BreakStatement {
            break_token,
            semicolon_token: _,
            id: _,
        }) => Some(break_token),
        AstNode::SkipStatement(SkipStatement {
            skip_token,
            semicolon_token: _,
            id: _,
        }) => Some(skip_token),

        AstNode::SelfExecutorHost(SelfExecutorHost { token, id: _ }) => Some(token),
        AstNode::ThreadExecutor(ThreadExecutor {
            host,
            dot_token: _,
            thread_token: _,
            open_bracket_token: _,
            index: _,
            close_bracket_token: _,
            id: _,
        }) => first_token_of_node(&host),
        AstNode::GPUExecutor(GPUExecutor {
            host,
            dot_token: _,
            gpus_token: _,
            open_bracket_token: _,
            gpu_index: _,
            close_bracket_token: _,
            id: _,
        }) => first_token_of_node(&host),
        AstNode::UnaryExpression(UnaryExpression {
            operator_token,
            operation: _,
            operand: _,
            id: _,
        }) => Some(operator_token),
        AstNode::CastExpression(CastExpression {
            operand,
            as_token: _,
            type_: _,
            id: _,
        }) => first_token_of_node(&*operand),
        AstNode::LiteralExpression(LiteralExpression {
            value: _,
            token,
            id: _,
        }) => Some(token),
        AstNode::ArrayExpression(ArrayExpression {
            open_bracket_token,
            elements: _,
            close_bracket_token: _,
            id: _,
        }) => Some(open_bracket_token),
        AstNode::BinaryExpression(BinaryExpression {
            left,
            operator_token: _,
            operation: _,
            right: _,
            id: _,
        }) => first_token_of_node(&*left),
        AstNode::GroupingExpression(GroupingExpression {
            open_paren_token,
            subexpression: _,
            close_paren_token: _,
            id: _,
        }) => Some(open_paren_token),

        AstNode::FunctionCallExpression(FunctionCallExpression {
            name: _,
            name_token,
            open_paren_token: _,
            arguments: _,
            close_paren_token: _,
            id: _,
        }) => Some(name_token),
        AstNode::CompilerExpression(CompilerExpression {
            at_token,
            name: _,
            name_token: _,
            open_paren_token: _,
            arguments: _,
            close_paren_token: _,
            id: _,
        }) => Some(at_token),
        AstNode::ArrayIndexExpression(ArrayIndexExpression {
            array,
            open_bracket_token: _,
            index: _,
            close_bracket_token: _,
            id: _,
        }) => first_token_of_node(&*array),
        AstNode::VariableAccessExpression(VariableAccessExpression {
            name: _,
            name_token,
            id: _,
        }) => Some(name_token),
        AstNode::VariableAssignmentExpression(VariableAssignmentExpression {
            lvalue,
            equal_token: _,
            right: _,
            id: _,
        }) => first_token_of_node(&lvalue),
        AstNode::VariableLValue(VariableLValue {
            name: _,
            name_token,
            id: _,
        }) => Some(name_token),
        AstNode::ArrayIndexLValue(ArrayIndexLValue {
            array,
            open_bracket_token: _,
            index: _,
            close_bracket_token: _,
            id: _,
        }) => first_token_of_node(&*array),
        AstNode::GroupingLValue(GroupingLValue {
            open_paren_token,
            sublvalue: _,
            close_paren_token: _,
            id: _,
        }) => Some(open_paren_token),
        AstNode::SimpleType(SimpleType {
            token,
            type_: _,
            id: _,
        }) => Some(token),
        AstNode::UnitType(UnitType {
            open_paren_token,
            close_paren_token: _,
            id: _,
        }) => Some(open_paren_token),
        AstNode::IdkType(IdkType { token, id: _ }) => Some(token),
        AstNode::ArrayType(ArrayType {
            subtype,
            open_bracket_token: _,
            size: _,
            close_bracket_token: _,
            id: _,
        }) => first_token_of_node(&*subtype),
    }
}
